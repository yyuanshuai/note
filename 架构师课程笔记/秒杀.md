

## 特点:

1. 瞬时大流量  需要对流量进行限制或者分散流量(cdn, 页面静态化)
2. 读多写少 都不可以直接操作数据库, 写可以酌情考虑
3. 用户量大, 商品数量有限, 最终创建的订单少

#### 针对特点1

##### 前端限流: 

1. 可以随意丢弃请求, 直接返回秒杀失败
2. 活动前置灰抢购按钮, 防止产生无效流量
3. 防暴击()

##### 后端限流: (网关限流, NGINX限流, 分布式信号量)

1. 令牌桶算法
2. IP访问限制
3. 用户黑名单
4. 参与资格校验
5. 熔断降级

> 可以选择现成的框架进行集成, 比如spring cloud gateway. sentinel
>
> 处理从流量应对大量流量场景外, 还可以引入缓存, 提高吞吐量, 但是同时会出现一些问题缓存穿透, 击穿, 需在秒杀活动开始前进行预热

若发生了缓存穿透击穿: 使用信号量tryLock放10个请求到数据库,如果数据库也没有, 



## 秒杀系统关注的问题

1. 服务单一职责+独立部署----秒杀服务及时自己扛不住压力, 挂掉. 不要影响别人
2. 秒杀连接加密----防止恶意攻击, 模拟秒杀请求. 防止连接暴露, 提前秒杀商品.
3. 库存预热+快速扣减----秒杀读多写少, 无需每次实时校验库存. 我们库存预热, 放到redis中. 信号量控制进来秒杀的请求
4. 动静分离----NGINX做好动静分离. 保证秒杀和商品详情页的动态请求才打到后端的服务集群. 使用cdn网络, 分担集群压力
5. 恶意请求拦截----识别非法攻击请求并进行拦截, 网关层
6. 流量错峰----使用各种手段, 将流量分担到更大宽度的时间点. 比如加验证码, 加入购物车
7. 限流&熔断&降级----限制次数, 限制总量, 快速失败降级运行, 熔断隔离防止雪崩
8. 队列削峰----10000个商品, 每个1000件秒杀, 双十一所有秒杀成功的请求, 进入队列, 慢慢创建订单, 扣减库存即可.



## 秒杀流程: 

#### 预热: 

秒杀商品的定时上架；每天晚上3点；上架最近三天需要秒杀的商品并生成随机码(只有开始秒杀才发出随机码, 以防恶意攻击, 模拟秒杀请求, 提前秒杀商品)。//注意幂等性处理

#### 点击秒杀

1. 传入秒杀商品skuid, 校验随机码, 数量
2. 校验秒杀合法性, skuid, 秒杀随机码(通过活动id+skuid,    111_222,      去redis获取随机码,比对)是否正确, 秒杀数量是否合法
3. 验证这个人是否已经购买过(购买过的用户在redis中标记一下, userId_skuId为key)。幂等性; 只要秒杀成功，就去占位。
4. 使用分布式信号量的方式, 尝试获取锁, 获得表示秒杀成功
5. 秒杀成功; 发送订单消息队列
6. 返回订单号

#### 订单模块监听秒杀队列

收到消息开始生成订单



#### 超卖少卖

##### 为什么会超卖 

- 答: 当很多请求进来的时候, 查询商品数量, 查到的数量都是同一个值, 下单完后, 库存减一后存入数据库, 也是同一个值, 所以很多人买到商品了,但是库存实际没有减少那么多

##### 超卖问题: 

- 使用乐观锁进行库存变更, 保证数据的安全性(乐观锁, 就是默认不会冲突的去修改, 尝试更改, 比如加个版本号字段. 这样修改时就会不成功)

##### 少卖问题: 

- 使用定时任务, 定期同步缓存和数据库中的数据

- 使用定时任务, 定期取消超时未支付的订单并恢复库存



#### 恶意请求

1. 动态url, 使用加密算法, 加密随机的字符串去做url, 然后通过前端代码获取url, 后台校验, 秒杀到时间是 , 才放出连接
2. IP限制同时可以防止黄牛, 友商的恶意刷单或捣乱
3. 增加算术验证码分辨真实用户机器人脚本






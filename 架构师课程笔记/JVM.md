# [Java 内存区域详解](https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/Java内存区域?id=java-内存区域详解)

# [JVM 垃圾回收](https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/JVM垃圾回收?id=jvm-垃圾回收)



# jvm虚拟机

### jvm分为三大块: 

#### 运行时数据区: 

##### 堆

##### 方法区(元空间)

> 方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 **Java 虚拟机规范把方法区描述为堆的一个逻辑部分**，但是它却有一个别名叫做 **Non-Heap（非堆）**，目的应该是与 Java 堆区分开来。

##### 栈

> 棧内有栈帧, 栈帧内有局部变量表, 操作数栈, 动态链接, 方法出口
>
> 每一次函数调用都会有一个对应的栈帧被压入 Java 栈,每一个函数调用结束后，都会有一个栈帧被弹出。
>
> 每定义一个局部变量就在局部变量表里加上

##### 本地方法栈

> 和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。
>
> 本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。
>
> 方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 `StackOverFlowError` 和 `OutOfMemoryError` 两种错误。

##### 程序计数器

> 程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。**字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。**
>
> 另外，**为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。**
>
> **从上面的介绍中我们知道程序计数器主要有两个作用：**
>
> 1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
> 2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。
>
> **注意：程序计数器是唯一一个不会出现 `OutOfMemoryError` 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。**



# JVM常用指令

## 普通对象内存布局: 

非数组类型的对象头的结构:

![对象头的信息](https://img-blog.csdnimg.cn/20190415101813830.png)

***如果一个对象计算过hashCode就会放到对象头里, 此时该对象将不能进入偏向锁***

1. 对象头, 在Hotsport里面称为markword长度是8字节
2. Classpointer指针: -XX:+UseCompressedClassPointers//开启:4字节,不开启8字节
3. 实例数据: 
   1. 成员变量,引用类型:-XX:+UseCompressedOops//开启:4字节,不开启8字节
4. padding对齐, 对齐是8的倍数,所以所有对象大小都是8的倍数,会被padding填充

## 指令

-XX:+UseCompressedClassPointers//开启对象头ClassPointer压缩,开启:4字节,不开启8字节

-XX:+UseCompressedOops//开启





# GC和调优*

### 如何标记对象是否是垃圾(垃圾如何定位)?

1. 引用计数
2. root searching(根可达算法)

### 如何清理垃圾的(垃圾如何回收)?

1. #### Mark-Sweep(标记清除)

   * 说明: 把垃圾标出来, 然后清掉
   * 执行次数: 两遍扫描, 第一遍找到有用对象象, 第二遍没用的清理掉
   * 优缺点: 位置不连续, 产生碎片, 执行效率偏低
   * 适用情况: 适用于存货对象较多的情况

2. #### Copy(复制)

   * 说明: 将内存分为两份, 将有用的对象复制到另一份内存中,再清掉这一整块内存
   * 执行次数: 1次
   * 优缺点: 空间浪费, 没有碎片, 效率高
   * 适用情况: 存货对象较少的情况

3. #### Mark-Compact(标记压缩)

   * 说明: 将所有的东西整理的过程,清理的过程同事压缩到头上去
   * 执行次数: 一遍找出有用对象 ,二遍进行移动
   * 优缺点: 效率低很多, 不会产生碎片
   * 适用情况: 存货对象较少的情况


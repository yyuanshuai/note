# 基础概念

线程指的是程序执行路径, 多线程就是多个执行路径, CPU在多个路径里来回切换.

```java
public class Main {
    public static void main(String[] args) {
        Runnable1 r = new Runnable1();
        Thread t = new Thread(r);
        t.start();
        for (int i = 0; i < 100; i++){
            System.out.printf("嘿嘿嘿");
        }
    }
}
class Runnable1 implements Runnable//还有继承Thread类的方法,一般使用接口方式实现, 方便灵活
{
    @Override
    public void run() {
        for (int i = 0; i < 100; i++){
            System.out.printf("啦啦啦");
        }
    }
}
输出: 
嘿嘿嘿
啦啦啦
嘿嘿嘿
```

**线程的状态: 新建状态, 就绪状态, 运行状态, 阻塞状态, 结束状态**

Thread的一些重要方法: 

```
进入就绪状态: 
	t.start()#使线程进入就绪状态,以供CPU调用
进入阻塞状态:
	t.join()#t1线程中执行语句t2.join();表示从t1切换到t2线程, t2线程执行结束后才执行t1线程
	o.wait()//在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待。所以一定要notify()唤醒wait()中的线程***执行该方法将释放锁***
	LockSupport.park()
进入Runing状态:
	o.notify()//唤醒在此对象监视器上等待的单个线程。***执行该方法不释放锁***
	LockSupport.unpark()
按照时间等待:
	Thread.sleep(time)
	o.wait(time)
	t.join(time)
	LockSupport.parkNanos()
	LockSupport.parkUntil()


t.interrupt()#中断线程(不要使用)。
t.isAlive()#测试线程是否处于活动状态


静态
Thread.yield()#暂停当前正在执行的线程对象，并执行其他线程
Thread.sleep(long millis)#在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。
Thread.holdsLock(Object obj)#当且仅当当前线程在指定的对象上保持监视器锁时，才返回 true。
Thread.currentThread()#返回对当前正在执行的线程对象的引用。
Thread.dumpStack()#将当前线程的堆栈跟踪打印至标准错误流。
t.setName(String name)#设置线程名
t.setPriority(int newPriority)#更改线程的优先级。
t.setDaemon(boolean on)#将该线程标记为守护线程或用户线程。
```

## 线程同步

#### synchronized用法:

```java
#执行该方法时, 查看当前对象是否被锁定, 被锁定则其他线程等待所释放后, 当前前程获得该锁后执行
public synchronized void add (String name){...}
#和上面用法是一样的意思
public void add (String name){
  synchronized (this){...}
}
```

##### 优化:

1. 该细粒度的细粒度 , 该粗粒度的粗粒度
2. 锁对象的时候不可以修改锁的对象(变量), 会导致同步不正常 
3. 不要使用String Integer 作为锁对象

##### 注意: 

1. synchronized是可重入的, 也就是说, synchronized m1()方法内可以调用 synchronized m2()方法的, 不会产生死锁
2. 修改同步, 获取不同步的话会产生脏读现象, 视需求来看获取需不需要将获取也改为同步(这样效率将变慢)
3. synchronized中的代码如果发生了异常, 锁将解除, 其他线程将进入, 需要做好异常后的处理
4. 如果锁的是static方法, 那么synchronized锁的是T.class对象(类对象)

非数组类型的对象头的结构:

![对象头的信息](https://img-blog.csdnimg.cn/20190415101813830.png)

1. 对象头里的MarkWord中两位(标志位)记录着该对象被锁情况 01:无锁,00:轻量级,10:重量级,11:标记为GC

##### 可重入性:

一个同步方法可以调用另外一个同步方法，一个线程已经拥有某个对象的锁，再次申请的时候仍然会得到该对象的锁.也就是说synchronized获得的锁是可重入的

##### 异常性: 

如果一个线程出现了异常, 那么该线程锁的对象将释放, 其他阻塞的线程将得到该锁执行. 

#### volatile

1. 保证线程的可见性

    > 多个线程访问同一个成员变量时, 当其中一个线程修改成员变量时, 其他线程获取该成员变量时, 还是oldvalue, 在成员变量上加上volatile可以解决该问题, 它是将线程工作内存的newvalue强制写回主内存, 其他线程工作内存马上获得通知修改为newvalue

2. 不保证原子性*

    > 也就是多个线程对这个volatile变量进行操作会存在丢失的情况

3. 禁止指令重排序(CPU) (单例模式中的Double Check Lock)

    > ...

volatile并不能保证多个线程共同修改running变量时所带来的不一致问题，也就是说volatile不能替代synchronized

#### ThreadLocal

ThreadLocal是一个本地线程副本变量工具类。内部是一个**弱引用**的Map来维护。这里不详细介绍它的原理，而是只是介绍它的使用，以后有独立章节来介绍ThreadLocal类的原理。

有些朋友称ThreadLocal为**线程本地变量**或**线程本地存储**。严格来说，ThreadLocal类并不属于多线程间的通信，而是让每个线程有自己”独立“的变量，线程之间互不影响。它为每个线程都创建一个**副本**，每个线程可以访问自己内部的副本变量。

ThreadLocal类最常用的就是set方法和get方法。示例代码：

```java
public class ThreadLocalDemo {
    static class ThreadA implements Runnable {
        private ThreadLocal<String> threadLocal;

        public ThreadA(ThreadLocal<String> threadLocal) {
            this.threadLocal = threadLocal;
        }

        @Override
        public void run() {
            threadLocal.set("A");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("ThreadA输出：" + threadLocal.get());
        }

        static class ThreadB implements Runnable {
            private ThreadLocal<String> threadLocal;

            public ThreadB(ThreadLocal<String> threadLocal) {
                this.threadLocal = threadLocal;
            }

            @Override
            public void run() {
                threadLocal.set("B");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("ThreadB输出：" + threadLocal.get());
            }
        }

        public static void main(String[] args) {
            ThreadLocal<String> threadLocal = new ThreadLocal<>();
            new Thread(new ThreadA(threadLocal)).start();
            new Thread(new ThreadB(threadLocal)).start();
        }
    }
}

// 输出：
ThreadA输出：A
ThreadB输出：B
```

可以看到，虽然两个线程使用的同一个ThreadLocal实例（通过构造方法传入），但是它们各自可以存取自己当前线程的一个值。

那ThreadLocal有什么作用呢？如果只是单纯的想要线程隔离，在每个线程中声明一个私有变量就好了呀，为什么要使用ThreadLocal？

如果开发者希望将类的某个静态变量（user ID或者transaction ID）与线程状态关联，则可以考虑使用ThreadLocal。

最常见的ThreadLocal使用场景为用来解决数据库连接、Session管理等。数据库连接和Session管理涉及多个复杂对象的初始化和关闭。如果在每个线程中声明一些私有变量来进行操作，那这个线程就变得不那么“轻量”了，需要频繁的创建和关闭连接。



## synchronized锁升级

### 1.无锁

### 2.偏向锁

对象头记录这个线程id

如果线程争用升级为轻量级锁(自旋锁)

### 3. 轻量级锁

自旋锁...十次自旋后升级为重量级锁

执行时间短(指加锁代码), 线程数少: 使用自旋锁

### 4. 重量级锁-OS

需要去申请操作系统资源的锁

执行时间长(指加锁代码), 线程数多: 使用重量级锁.

## interview

1. 实现一个容器，提供两个方法，add，size,写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到5个时，线程2给出提示并结束 
2. 面试题：写一个固定容量同步容器，拥有put和get方法，以及getCount方法，能够支持2个生产者线程以及10个消费者线程的阻塞调用

```java
/**
 * 面试题：写一个固定容量同步容器，拥有put和get方法，以及getCount方法，
 * 能够支持2个生产者线程以及10个消费者线程的阻塞调用
 * 
 * 使用wait和notify/notifyAll来实现
 * 
 * 使用Lock和Condition来实现
 * 对比两种方式，Condition的方式可以更加精确的指定哪些线程被唤醒
 */
package com.mashibing.juc.c_021_01_interview;

import java.util.LinkedList;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class MyContainer2<T> {
	final private LinkedList<T> lists = new LinkedList<>();
	final private int MAX = 10; //最多10个元素
	private int count = 0;
	
	private Lock lock = new ReentrantLock();
	private Condition producer = lock.newCondition();
	private Condition consumer = lock.newCondition();
	
	public void put(T t) {
        lock.lock();
		try {
			while(lists.size() == MAX) { //为什么用while而不是用if？
				producer.await();
			}
			lists.add(t);
			++count;
			consumer.signalAll(); //通知消费者线程进行消费
		} catch (InterruptedException e) {
			e.printStackTrace();
		} finally {
			lock.unlock();
		}
	}
	
	public T get() {
		T t = null;
        lock.lock();
		try {
			while(lists.size() == 0) {
				consumer.await();
			}
			t = lists.removeFirst();
			count --;
			producer.signalAll(); //通知生产者进行生产
		} catch (InterruptedException e) {
			e.printStackTrace();
		} finally {
			lock.unlock();
		}
		return t;
	}
	
	public static void main(String[] args) {
		MyContainer2<String> c = new MyContainer2<>();
		//启动消费者线程
		for(int i=0; i<10; i++) {
			new Thread(()->{
				for(int j=0; j<5; j++) System.out.println(c.get());
			}, "c" + i).start();
		}
		
		try {
			TimeUnit.SECONDS.sleep(2);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		
		//启动生产者线程
		for(int i=0; i<2; i++) {
			new Thread(()->{
				for(int j=0; j<25; j++) c.put(Thread.currentThread().getName() + " " + j);
			}, "p" + i).start();
		}
	}
}
```



1. 一个线程打印1-x, 另一个线程打印a-z, 两个线程交叉打印a1,b2,c3,d4,...,z26









# CAS

### 什么是CAS:

CAS 的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset。另外 value 是一个 volatile 变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。



> CAS （Compare And Swap） 指令是一个CPU层级的原子性操作指令。 在 Intel 处理器中， 其汇编指令为 cmpxchg。
>
> 该指令概念上存在 3 个参数， 第一个参数【目标地址】， 第二个参数【值1】， 第三个参数【值2】， 指令会比较【目标地址存储的内容】和 【值1】 是否一致， 如果一致， 则将【值 2】 填写到【目标地址】， 其语义可以用如下的伪代码表示。

### Unsafe

Atomic类都是使用CAS进行操作的, CAS又是依靠Unsafe类来实现的

```java
//AtomicInteger以原子的方式将当前值加一
public final int getAndIncrement() {
    return unsafe.getAndAddInt(this, valueOffset, 1);
}

//Unsafe类源码
public final int getAndSetInt(Object var1, long var2, int var4) {
    int var5;
    do {
        var5 = this.getIntVolatile(var1, var2);
    } while(!this.compareAndSwapInt(var1, var2, var5, var4));
    return var5;
}

this.compareAndSwapInt(var1, var2, var5, var4);//该方法时native的, 是由汇编指令来完成的, cmpxchg(x,addr,e)

//var1: AtomicInteger对象本身
//var2: 该对象值得引用地址
//var4: 需要变动的数量
//var5: 是用过var1 var2找出的主内存中真实的值
//如果相同, 更新var5+var4并且返回true
//如果不同, 继续取值然后再比较, 直到更新完成
```

**CAS相比synchronized加锁方式相比提高了并发能力, 但是带来了更多的CPU资源开销**





### CAS实现原子操作的三大问题

### ABA问题: 

当一个线程把值从A修改为B, 再把B修改为A, 其他线程不知道中间经过了这个骚操作, 就将A修改为了X

ABA问题的解决思路是在变量前面追加上**版本号或者时间戳**。从JDK 1.5开始，JDK的atomic包里提供了一个类`AtomicReference` `AtomicStampedReference`类来解决ABA问题。

这个类的`compareAndSet`方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果二者都相等，才使用CAS设置为新的值和标志。

###  循环时间长开销大

CAS多与自旋结合。如果自旋CAS长时间不成功，会占用大量的CPU资源。

解决思路是让JVM支持处理器提供的**pause指令**。

pause指令能让自旋失败时cpu睡眠一小段时间再继续自旋，从而使得读操作的频率低很多,为解决内存顺序冲突而导致的CPU流水线重排的代价也会小很多。

### 只能保证一个共享变量的原子操作

这个问题你可能已经知道怎么解决了。有两种解决方案：

1. 使用JDK 1.5开始就提供的`AtomicReference`类保证对象之间的原子性，把多个变量放到一个对象里面进行CAS操作；
2. 使用锁。锁内的临界区代码可以保证只有当前线程能操作。







## 多线程递增数字的几个方法: 

1. 使用synchronized
2. 使用AtomicInteger
   1. 比sync要快, 因为不加锁, sync有可能申请重量级锁, 所以效率偏低.
3. 使用LongAdder
   1. LongAdder是效率最高的, 但是线程数少或操作数量少也未必有优势, 所以实际开发中用哪种要考虑并发有多高.
   2. 比atomic效率高, 因为LongAdder的内部做了分段锁, 类似于分段锁的概念. 







# [AbstractQueuedSynchronizer](https://javadoop.com/post/AbstractQueuedSynchronizer)

(AbstractQueuedSynchronizer:即队列同步器)

[从ReentrantLock的实现看AQS的原理及应用 - 美团技术团队](https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html)

[一行一行源码分析清楚AbstractQueuedSynchronizer](https://javadoop.com/post/AbstractQueuedSynchronizer)





### ReentrantLock

reentrantlock用于替代synchronized, 它具有与使用 `synchronized` 方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大

用法: 

```java
private final ReentrantLock lock = new ReentrantLock();
public void m() { 
    lock.lock();  // block until condition holds
    try {
        // ... method body
    } finally {
        lock.unlock();
    }
}
```

```java
boolean locked = lock.tryLock(5, TimeUnit.SECONDS);//尝试锁定, 不管锁定与否,方法都继续执行
lock.lockInterruptibly();//可以对interrupt()方法做出响应(当t1线程lock()时, t2线程lockInterruptibly()的话, 可以被interrupt打断继续往下执行, 不会等待t1,unlock())
lock.interrupt();
```

```java
private final ReentrantLock lock = new ReentrantLock(true);//公平锁,队列中,谁先入队,谁先执行
```

与synchronized的区别:

1. ReentrantLock加锁后必须手动解锁, synchronized自动加锁自动解锁
2. ReentrantLock是CAS实现, synchronized是锁的四种状态升级
3. ReentrantLock有公平机制
4. ReentrantLock更灵活, 比如尝试锁定操作, 能够控制等待中的线程, 使其继续执行(lockInterruptibly())
5. ReentrantLock可以指定线程类型进行特定类型的操作, 比如下面的面试题中, 指定其他消费者线程消费, 而不指定生产者生产.

### CountDownLatch

一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。

当latch不为0时,所有线程中latch.await();都将阻塞, 只有latch.countDown();操作一直减到0时, latch.await()将往下执行

```java
import java.util.concurrent.CountDownLatch;
public class T06_TestCountDownLatch {
    public static void main(String[] args) {
        usingJoin();
        usingCountDownLatch();
    }
    private static void usingCountDownLatch() {
        Thread[] threads = new Thread[100];
        CountDownLatch latch = new CountDownLatch(threads.length);
        for(int i=0; i<threads.length; i++) {
            threads[i] = new Thread(()->{
                int result = 0;
                for(int j=0; j<10000; j++) result += j;
                latch.countDown();
            });
        }
        for (int i = 0; i < threads.length; i++) {
            threads[i].start();
        }
        try {
            latch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("end latch");
    }
    private static void usingJoin() {
        Thread[] threads = new Thread[100];
        for(int i=0; i<threads.length; i++) {
            threads[i] = new Thread(()->{
                int result = 0;
                for(int j=0; j<10000; j++) result += j;
            });
        }
        for (int i = 0; i < threads.length; i++) {
            threads[i].start();
        }
        for (int i = 0; i < threads.length; i++) {
            try {
                threads[i].join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println("end join");
    }
}
```

### CyclicBarrier

一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。在涉及一组固定大小的线程的程序中，这些线程必须不时地互相等待，此时 CyclicBarrier 很有用。因为该 barrier 在释放等待线程后可以重用，所以称它为*循环* 的 barrier。

当barrier不为n时,所有线程中barrier.await();都将阻塞, 只有barrier.await();操作一直加到n时, barrier.await()将往下执行

```java
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;
public class T07_TestCyclicBarrier {
    public static void main(String[] args) {
        //CyclicBarrier barrier = new CyclicBarrier(20);
        CyclicBarrier barrier = new CyclicBarrier(20, () -> System.out.println("满人,发车"));

        /*CyclicBarrier barrier = new CyclicBarrier(20, new Runnable() {
                    @Override
                    public void run() {
                        System.out.println("满人,发车");
                    }
                });*/

        for(int i=0; i<100; i++) {
            new Thread(()->{
                try {
                    barrier.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }
            }).start();
        }
    }
}
```

### Phaser

> 一个可重复使用的同步屏障，功能类似于[`CyclicBarrier`](https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/concurrent/CyclicBarrier.html)和[`CountDownLatch`，](https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/concurrent/CountDownLatch.html)但支持更灵活的使用。



### MarriagePhaser

作用: 阶段性阻塞. 比如下面代码, 7个人到齐了才吃饭, 7个人吃完饭才离开. (7个线程到了某个状态,时间点,才继续走下一个阶段的意思. 可以允许线程跳过阶段)

```java
import java.util.Random;
import java.util.concurrent.Phaser;
import java.util.concurrent.TimeUnit;

public class T09_TestPhaser2 {
    static Random r = new Random();
    static MarriagePhaser phaser = new MarriagePhaser();
    static void milliSleep(int milli) {
        try {
            TimeUnit.MILLISECONDS.sleep(milli);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    public static void main(String[] args) {
        phaser.bulkRegister(7);
        for(int i=0; i<5; i++) {
            new Thread(new Person("p" + i)).start();
        }
        new Thread(new Person("新郎")).start();
        new Thread(new Person("新娘")).start();
    }
    static class MarriagePhaser extends Phaser {
        @Override
        protected boolean onAdvance(int phase, int registeredParties) {
            switch (phase) {
                case 0:
                    System.out.println("所有人到齐了！" + registeredParties);
                    System.out.println();
                    return false;
                case 1:
                    System.out.println("所有人吃完了！" + registeredParties);
                    System.out.println();
                    return false;
                case 2:
                    System.out.println("所有人离开了！" + registeredParties);
                    System.out.println();
                    return false;
                case 3:
                    System.out.println("婚礼结束！新郎新娘抱抱！" + registeredParties);
                    return true;
                default:
                    return true;
            }
        }
    }
    static class Person implements Runnable {
        String name;
        public Person(String name) {
            this.name = name;
        }
        public void arrive() {
            milliSleep(r.nextInt(1000));
            System.out.printf("%s 到达现场！\n", name);
            phaser.arriveAndAwaitAdvance();
        }
        public void eat() {
            milliSleep(r.nextInt(1000));
            System.out.printf("%s 吃完!\n", name);
            phaser.arriveAndAwaitAdvance();
        }
        public void leave() {
            milliSleep(r.nextInt(1000));
            System.out.printf("%s 离开！\n", name);
            phaser.arriveAndAwaitAdvance();
        }
        private void hug() {
            if(name.equals("新郎") || name.equals("新娘")) {
                milliSleep(r.nextInt(1000));
                System.out.printf("%s 洞房！\n", name);
                phaser.arriveAndAwaitAdvance();
            } else {
                phaser.arriveAndDeregister();
                //phaser.register()
            }
        }
        @Override
        public void run() {
            arrive();
            eat();
            leave();
            hug();
        }
    }
}
```

### ReentrantReadWriteLock

**作用:** 

- `读锁又称为共享锁`，简称S锁，顾名思义，共享锁就是多个线程可以共享一把读锁
- `写锁又称为排他锁`，简称X锁，顾名思义，排他锁就是不能与其他线程读写锁并存，**所有的读线程和其他的写线程都会被阻塞**

```java
import java.util.Random;
import java.util.concurrent.atomic.LongAdder;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

public class T10_TestReadWriteLock {
    private static int value;
    static Lock lock = new ReentrantLock();
    static ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
    static Lock readLock = readWriteLock.readLock();
    static Lock writeLock = readWriteLock.writeLock();

    public static void read(Lock lock) {
        try {
            lock.lock();
            Thread.sleep(1000);
            //模拟读取操作
            System.out.println("read over!");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
    public static void write(Lock lock, int v) {
        try {
            lock.lock();
            Thread.sleep(1000);
            value = v;
            //模拟写操作
            System.out.println("write over!");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
    public static void main(String[] args) {
        //Runnable readR = ()-> read(lock);
        //Runnable writeR = ()->write(lock, new Random().nextInt());
        //上面执行20秒 , 下面执行3秒
        Runnable readR = ()-> read(readLock);
        Runnable writeR = ()->write(writeLock, new Random().nextInt());

        for(int i=0; i<18; i++) new Thread(readR).start();
        for(int i=0; i<2; i++) new Thread(writeR).start();
    }
}
```

### StampedLock

...请补充

### Semaphore

一个计数信号量。从概念上讲，信号量维护了一个许可集。如有必要，在许可可用前会阻塞每一个 [`acquire()`](http://itmyhome.com/java-api/java/util/concurrent/Semaphore.html#acquire())，然后再获取该许可。每个 [`release()`](http://itmyhome.com/java-api/java/util/concurrent/Semaphore.html#release()) 添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，`Semaphore` 只对可用许可的号码进行计数，并采取相应的行动。

new Semaphore(2, true);表示允许两个线程同时执行,其他线程acquire()阻塞, 直到s.release()归还, 则其他某一个线程获得执行

```java
import java.util.concurrent.Semaphore;
public class T11_TestSemaphore {
    public static void main(String[] args) {
        //Semaphore s = new Semaphore(2);
        Semaphore s = new Semaphore(2, true);
        //允许一个线程同时执行
        //Semaphore s = new Semaphore(1);
        
        new Thread(()->{
            try {
                s.acquire();
                System.out.println("T1 running...");
                Thread.sleep(200);
                System.out.println("T1 running...");
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                s.release();
            }
        }).start();
      
        new Thread(()->{
            try {
                s.acquire();
                System.out.println("T2 running...");
                Thread.sleep(200);
                System.out.println("T2 running...");
                s.release();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
    }
}
```

### Exchanger

线程之间交换数据

```java
import java.util.concurrent.Exchanger;

public class T12_TestExchanger {
    static Exchanger<String> exchanger = new Exchanger<>();
    public static void main(String[] args) {
        new Thread(()->{
            String s = "T1";
            try {
                s = exchanger.exchange(s);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + " " + s);
        }, "t1").start();

        new Thread(()->{
            String s = "T2";
            try {
                s = exchanger.exchange(s);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + " " + s);
        }, "t2").start();
    }
}
```

### LockSupport

java锁和同步器框架的核心AQS: AbstractQueuedSynchronizer, 就是通过调用LockSupport.park()和LockSupport.unpark(t)的方法, 来实现线程的阻塞和唤醒.

```java
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.LockSupport;

public class T13_TestLockSupport {
    public static void main(String[] args) {
        Thread t = new Thread(()->{
            for (int i = 0; i < 10; i++) {
                System.out.println(i);
                if(i == 5) {
                    LockSupport.park();
                }
                try {
                    TimeUnit.SECONDS.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        t.start();
//        LockSupport.unpark(t);
        try {
            TimeUnit.SECONDS.sleep(8);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("after 8 senconds!");
        LockSupport.unpark(t);
    }
}
```

以前阻塞和唤醒某一个具体的线程有很多限制, 比如:

1. 因为wait()方法需要释放锁, 所以必须在synchronized中使用, 否则抛出异常IllegalMonitorStateException
2. notify()方法特必须在synchronized中使用, 并且应该指定对象
3. synchronized(), wait(), notify(), 对象必须一致, 一个synchronized()代码块中只能有一个线程调用wait()或notify()

LockSupport是一个线程阻塞工具类, 所有的方法都是静态方法, 可以让线程在任意位置阻塞, 阻塞之后也有对应的唤醒方法, 归根结底, LockSupport调用的Unsafe中的native代码, 

调用unpark(), 凭证为零就加一, 调用park()就消费凭证,  凭证是不可累计, 凭证范围0~1

为什么可一线唤醒线程后阻塞线程? 

因为unpark获得一个凭证, 之后再调用park()方法, 就可以凭证消费, 所以不会阻塞.





### 面试题

实现一个容器, 提供两个方法add, size, 写两个线程:

线程1, 添加10个元素到容器中

线程2, 实时监控元素个数, 当个数到5个时, 线程2给出提示并结束

```java
解1:
public class T04_NotifyFreeLock {
    volatile List lists = new ArrayList();
    public void add(Object o) {
        lists.add(o);
    }
    public int size() {
        return lists.size();
    }
    public static void main(String[] args) {
        T04_NotifyFreeLock c = new T04_NotifyFreeLock();
        final Object lock = new Object();
        new Thread(() -> {
            synchronized(lock) {
				System.out.println("t2启动");
                if(c.size() != 5) {
                    try {
                        lock.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
				System.out.println("t2 结束");
                lock.notify();
            }
        }, "t2").start();
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e1) {
            e1.printStackTrace();
        }
        new Thread(() -> {
            synchronized(lock) {
                for(int i=0; i<10; i++) {
                    c.add(new Object());
                    System.out.println("add " + i);
                    if(c.size() == 5) {
                        lock.notify();
                        try {
                            lock.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                    try {
                        TimeUnit.SECONDS.sleep(1);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }, "t1").start();
    }
}
解2: 
public class T07_LockSupport_WithoutSleep {
	volatile List lists = new ArrayList();
	public void add(Object o) {
		lists.add(o);
	}
	public int size() {
		return lists.size();
	}
	static Thread t1 = null, t2 = null;
	public static void main(String[] args) {
		T07_LockSupport_WithoutSleep c = new T07_LockSupport_WithoutSleep();
		t1 = new Thread(() -> {
			System.out.println("t1启动");
			for (int i = 0; i < 10; i++) {
				c.add(new Object());
				System.out.println("add " + i);
				if (c.size() == 5) {
					LockSupport.unpark(t2);
					LockSupport.park();
				}
			}
		}, "t1");
		t2 = new Thread(() -> {
            LockSupport.park();
			System.out.println("到达" + size());
			LockSupport.unpark(t1);
		}, "t2");
		t2.start();
		t1.start();
	}
}
```

面试题：写一个固定容量同步容器，拥有put和get方法，以及getCount方法，能够支持2个生产者线程以及10个消费者线程的阻塞调用

```java
解法1:
public class MyContainer1<T> {
	final private LinkedList<T> lists = new LinkedList<>();
	final private int MAX = 10; //最多10个元素
	private int count = 0;
	public synchronized void put(T t) {
		while(lists.size() == MAX) { //想想为什么用while而不是用if？
			try {
				this.wait(); //effective java
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
		lists.add(t);
		++count;
		this.notifyAll(); //通知消费者线程进行消费
	}
	public synchronized T get() {
		T t = null;
		while(lists.size() == 0) {
			try {
				this.wait();
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
		t = lists.removeFirst();
		count --;
		this.notifyAll(); //通知生产者进行生产
		return t;
	}
	public static void main(String[] args) {
		MyContainer1<String> c = new MyContainer1<>();
		//启动消费者线程
		for(int i=0; i<10; i++) {
			new Thread(()->{
				for(int j=0; j<5; j++) System.out.println(c.get());
			}, "c" + i).start();
		}
		try {
			TimeUnit.SECONDS.sleep(2);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		//启动生产者线程
		for(int i=0; i<2; i++) {
			new Thread(()->{
				for(int j=0; j<25; j++) c.put(Thread.currentThread().getName() + " " + j);
			}, "p" + i).start();
		}
	}
}
解法2:
public class MyContainer2<T> {
	final private LinkedList<T> lists = new LinkedList<>();
	final private int MAX = 10; //最多10个元素
	private int count = 0;
	
	private Lock lock = new ReentrantLock();
	private Condition producer = lock.newCondition();
	private Condition consumer = lock.newCondition();
	
	public void put(T t) {
		try {
			lock.lock();
			while(lists.size() == MAX) { //想想为什么用while而不是用if？
				producer.await();
			}
			lists.add(t);
			++count;
			consumer.signalAll(); //通知消费者线程进行消费
		} catch (InterruptedException e) {
			e.printStackTrace();
		} finally {
			lock.unlock();
		}
	}
	public T get() {
		T t = null;
		try {
			lock.lock();
			while(lists.size() == 0) {
				consumer.await();
			}
			t = lists.removeFirst();
			count --;
			producer.signalAll(); //通知生产者进行生产
		} catch (InterruptedException e) {
			e.printStackTrace();
		} finally {
			lock.unlock();
		}
		return t;
	}
	public static void main(String[] args) {
		MyContainer2<String> c = new MyContainer2<>();
		//启动消费者线程
		for(int i=0; i<10; i++) {
			new Thread(()->{
				for(int j=0; j<5; j++) System.out.println(c.get());
			}, "c" + i).start();
		}
		try {
			TimeUnit.SECONDS.sleep(2);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		//启动生产者线程
		for(int i=0; i<2; i++) {
			new Thread(()->{
				for(int j=0; j<25; j++) c.put(Thread.currentThread().getName() + " " + j);
			}, "p" + i).start();
		}
	}
}
```

两个线程交叉打印1a2b3c4d5e......

```java
解1:
public class T06_00_sync_wait_notify {
    public static void main(String[] args) {
        final Object o = new Object();
        char[] aI = "1234567".toCharArray();
        char[] aC = "ABCDEFG".toCharArray();
        new Thread(()->{
            synchronized (o) {
                for(char c : aI) {
                    System.out.print(c);
                    try {
                        o.notify();
                        o.wait(); //让出锁
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                o.notify(); //必须，否则无法停止程序
            }
        }, "t1").start();
        new Thread(()->{
            synchronized (o) {
                for(char c : aC) {
                    System.out.print(c);
                    try {
                        o.notify();
                        o.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                o.notify();
            }
        }, "t2").start();
    }
}
解2:LockSupport
public class T02_00_LockSupport {
    static Thread t1 = null, t2 = null;
    public static void main(String[] args) throws Exception {
        char[] aI = "1234567".toCharArray();
        char[] aC = "ABCDEFG".toCharArray();
        t1 = new Thread(() -> {
                for(char c : aI) {
                    System.out.print(c);
                    LockSupport.unpark(t2); //叫醒T2
                    LockSupport.park(); //T1阻塞
                }
        }, "t1");
        t2 = new Thread(() -> {

            for(char c : aC) {
                LockSupport.park(); //t2阻塞
                System.out.print(c);
                LockSupport.unpark(t1); //叫醒t1
            }
        }, "t2");
        t1.start();
        t2.start();
    }
}
解3:LinkedTransferQueue
public class T13_TransferQueue {
    public static void main(String[] args) {
        char[] aI = "1234567".toCharArray();
        char[] aC = "ABCDEFG".toCharArray();
        TransferQueue<Character> queue = new LinkedTransferQueue<Character>();
        new Thread(()->{
            try {
                for (char c : aI) {
                    System.out.print(queue.take());
                    queue.transfer(c);
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "t1").start();
        new Thread(()->{
            try {
                for (char c : aC) {
                    queue.transfer(c);
                    System.out.print(queue.take());
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "t2").start();
    }
}
```





# 同步容器

## 同步容器类的演变

Hashtable(全部方法加锁)->HashMap(无锁)->SynchronizedHashMap(锁工具)->ConcurrentHashMap(多线程版本,红黑树,主要提高在读上面)

Vector(全部方法加锁)->LinkedList(无锁)->ConcurrentLinkedQueue(高并发版本, )

## Collection

### List

#### ArrayList

#### LinkedList

#### Stack

#### CopyOnWriteList



### Set

#### HashSet

#### LinkedHashSet

#### CopyOnWriteSet



### Queue

和list的区别是添加了offer,peek,poll,put,take这些对线程友好的或者阻塞,或者等待的方法

```java
Queue接口提供的方法
    offer()#如果在不违反容量限制的情况下立即执行，则将指定的元素插入到此队列中。当使用容量限制队列时，此方法通常优于add(E)。成功返回true
    put()#在该队列的尾部插入指定的元素。
    take()#检索并删除此队列的头，如有必要，等待元素可用。
    poll()#检索并删除此队列的头，如果此队列为空，则返回 null 。
    poll(long timeout, TimeUnit unit)#获取并移除此队列的头部，在指定的等待时间前等待可用的元素（如果有必要）。
    peek()#检索但不删除此队列的头，如果此队列为空，则返回 null 。
```

#### Deque(双端队列)

#### BlockingQueue(阻塞队列-线程安全)*

| 方法\处理方式 | 抛出异常  | 返回特殊值 | 一直阻塞   | 超时退出           |
| ------------- | --------- | ---------- | ---------- | ------------------ |
| 插入方法      | add(e)    | offer(e)   | **put(e)** | offer(e,time,unit) |
| 移除方法      | remove()  | poll()     | **take()** | poll(time,unit)    |
| 检查方法      | element() | peek()     | -          | -                  |

- 抛出异常：如果试图的操作无法立即执行，抛异常。当阻塞队列满时候，再往队列里插入元素，会抛出IllegalStateException(“Queue full”)异常。当队列为空时，从队列里获取元素时会抛出NoSuchElementException异常 。
- 返回特殊值：如果试图的操作无法立即执行，返回一个特殊值，通常是true / false。
- 一直阻塞：如果试图的操作无法立即执行，则一直阻塞或者响应中断。
- 超时退出：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功，通常是 true / false。 



##### ArrayBlockingQueue

> 由**数组**结构组成的**有界**阻塞队列。内部结构是数组，故具有数组的特性。加到满会阻塞
>

##### LinkedBlockingQueue

> 由**链表**结构组成的**有界**阻塞队列。内部结构是链表，具有链表的特性。默认队列的大小是`Integer.MAX_VALUE`，也可以指定大小。此队列按照**先进先出**的原则对元素进行排序。
>

##### DelayQueue

> 能实现按照在里面等待的时间来排序. 要求你必须实现Delay接口,本质上是一个PriorityQueue
>
> 该队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素 。注入其中的元素必须实现 java.util.concurrent.Delayed 接口。 
>
> DelayQueue是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。

##### SynchronousQueue

> 一个线程往里put一个元素就阻塞, 不能在put, 等待另一个线程往外take后, 才继续往下走,反之亦然
>
> 这个队列比较特殊，**没有任何内部容量**，甚至连一个队列的容量都没有。并且每个 put 必须等待一个 take，反之亦然。
>
> 需要区别容量为1的ArrayBlockingQueue、LinkedBlockingQueue。
>
> 以下方法的返回值，可以帮助理解这个队列：
>
> - iterator() 永远返回空，因为里面没有东西
>- peek() 永远返回null
> - put() 往queue放进去一个element以后就一直wait直到有其他thread进来把这个element取走。
> - offer() 往queue里放一个element后立即返回，如果碰巧这个element被另一个thread取走了，offer方法返回true，认为offer成功；否则返回false。
> - take() 取出并且remove掉queue里的element，取不到东西他会一直等。
> - poll() 取出并且remove掉queue里的element，只有到碰巧另外一个线程正在往queue里offer数据或者put数据的时候，该方法才会取到东西。否则立即返回null。
> - isEmpty() 永远返回true
> - remove()&removeAll() 永远返回false

##### TransferQueue?

> void transfer(E e)
> 将元素转移给消费者，如有必要，等待。
> 更确切地说，如果存在已经等待接收消费者的消费者（ BlockingQueue.take()或定时器poll ），则立即转移指定元素，否则等待消费者收到该元素。

##### PriorityQueue

> 基于优先级的无界阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定），内部控制线程同步的锁采用的是公平锁。

#### ConcurrentLinkedQueue

高并发链表队列

## Map

### HashMap(无序,线程不安全)

### TreeMap(有序,线程不安全)

### WeakHashMap

### ConcurrentHashMap(无序,线程安全)

### ConcurrentSkipMap(有序,线程安全)





# 线程池

## Executors*

这是一个线程池工厂,可以新建各种线程池对象

阿里不用这些东西, 因为队列大小问题, 线程多少问题, 都是阿里自己控制

### Executors.newSingleThreadExecutor();

```java
    public static ExecutorService newSingleThreadExecutor() {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>()));
    }
```

有且仅有一个核心线程（ corePoolSize == maximumPoolSize=1），使用了LinkedBlockingQueue（容量很大），所以，**不会创建非核心线程**。所有任务按照**先来先执行**的顺序执行。如果这个唯一的线程不空闲，那么新来的任务会存储在任务队列里等待执行。



### Executors.newCachedThreadPool();

```
return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                              60L, TimeUnit.SECONDS,
                              new SynchronousQueue<Runnable>());
```

`CacheThreadPool`的**运行流程**如下：

1. 提交任务进线程池。
2. 因为**corePoolSize**为0的关系，不创建核心线程，线程池最大为Integer.MAX_VALUE。
3. 尝试将任务添加到**SynchronousQueue**队列。
4. 如果SynchronousQueue入列成功，等待被当前运行的线程空闲后拉取执行。如果当前没有空闲线程，那么就创建一个非核心线程，然后从SynchronousQueue拉取任务并在当前线程执行。
5. 如果SynchronousQueue已有任务在等待，入列操作将会阻塞。

当需要执行很多**短时间**的任务时，CacheThreadPool的线程复用率比较高， 会显著的**提高性能**。而且线程60s后会回收，意味着即使没有任务进来，CacheThreadPool并不会占用很多资源。



### Executors.newFixedThreadPool(cpuCoreNum);

```
return new ThreadPoolExecutor(nThreads, nThreads,
                              0L, TimeUnit.MILLISECONDS,
                              new LinkedBlockingQueue<Runnable>());
```

核心线程数量和总线程数量相等，都是传入的参数nThreads，所以只能创建核心线程，不能创建非核心线程。因为LinkedBlockingQueue的默认大小是Integer.MAX_VALUE，故如果核心线程空闲，则交给核心线程处理；如果核心线程不空闲，则入列等待，直到核心线程空闲。

**与CachedThreadPool的区别**：

- 因为 corePoolSize == maximumPoolSize ，所以FixedThreadPool只会创建核心线程。 而CachedThreadPool因为corePoolSize=0，所以只会创建非核心线程。
- 在 getTask() 方法，如果队列里没有任务可取，线程会一直阻塞在 LinkedBlockingQueue.take() ，线程不会被回收。 CachedThreadPool会在60s后收回。
- 由于线程不会被回收，会一直卡在阻塞，所以**没有任务的情况下， FixedThreadPool占用资源更多**。 
- 都几乎不会触发拒绝策略，但是原理不同。FixedThreadPool是因为阻塞队列可以很大（最大为Integer最大值），故几乎不会触发拒绝策略；CachedThreadPool是因为线程池很大（最大为Integer最大值），几乎不会导致线程数量大于最大线程数，故几乎不会触发拒绝策略。


newFixedThreadPool(int)适用于执行长期的任务

newCachedThreadPool()适用于指定很多短



### Executors.newScheduledThreadPool(4);

```java
public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
    return new ScheduledThreadPoolExecutor(corePoolSize);
}

//ScheduledThreadPoolExecutor():
public ScheduledThreadPoolExecutor(int corePoolSize) {
    super(corePoolSize, Integer.MAX_VALUE,
          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,
          new DelayedWorkQueue());
}
```





### Executors.newWorkStealingPool();





> 四种常见的线程池基本够我们使用了，但是《阿里把把开发手册》不建议我们直接使用Executors类中的线程池，而是通过`ThreadPoolExecutor`的方式，这样的处理方式让写的同学需要更加明确线程池的运行规则，规避资源耗尽的风险。
>
> 但如果你及团队本身对线程池非常熟悉，又确定业务规模不会大到资源耗尽的程度（比如线程数量或任务队列长度可能达到Integer.MAX_VALUE）时，其实是可以使用JDK提供的这几个接口的，它能让我们的代码具有更强的可读性。

## ThreadPoolExecutor*

往线程池内扔任务: 

从0个任务开始, 扔第一个...扔到核心线程数时, 在扔的话进入队列, 继续扔...到队列满时, 开最大线程数继续执行任务, 最大线程数满时, 继续扔就会执行拒绝任务处理,jdk默认有4中拒绝处理方式. 可以自定义处理方式..

```java
ThreadPoolExecutor(
	int corePoolSize, //核心线程
	int maximumPoolSize, //最大线程
	long keepAliveTime, //空闲线程存活时间
	TimeUnit unit, //时间单位
	BlockingQueue<Runnable> workQueue, //队列类型
	ThreadFactory threadFactory, //线程工厂, 定义线程如何new, 线程名, 线程组
	RejectedExecutionHandler handler//拒绝任务处理, 线程满了, 队列也满了, 加进来的任务就执行这个处理, 该放Redis放Redis, 放mysql,放kafka
)
```

### ThreadPoolExecutor源码解析

![图解线程池实现原理](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/%E5%9B%BE%E8%A7%A3%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png)

### 1、常用变量的解释

```java
// 1. `ctl`，可以看做一个int类型的数字，高3位表示线程池状态，低29位表示worker数量
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
// 2. `COUNT_BITS`，`Integer.SIZE`为32，所以`COUNT_BITS`为29
private static final int COUNT_BITS = Integer.SIZE - 3;
// 3. `CAPACITY`，线程池允许的最大线程数。1左移29位，然后减1，即为 2^29 - 1
private static final int CAPACITY   = (1 << COUNT_BITS) - 1;

// runState is stored in the high-order bits
// 4. 线程池有5种状态，按大小排序如下：RUNNING < SHUTDOWN < STOP < TIDYING < TERMINATED
private static final int RUNNING    = -1 << COUNT_BITS;
private static final int SHUTDOWN   =  0 << COUNT_BITS;
private static final int STOP       =  1 << COUNT_BITS;
private static final int TIDYING    =  2 << COUNT_BITS;
private static final int TERMINATED =  3 << COUNT_BITS;

// Packing and unpacking ctl
// 5. `runStateOf()`，获取线程池状态，通过按位与操作，低29位将全部变成0
private static int runStateOf(int c)     { return c & ~CAPACITY; }
// 6. `workerCountOf()`，获取线程池worker数量，通过按位与操作，高3位将全部变成0
private static int workerCountOf(int c)  { return c & CAPACITY; }
// 7. `ctlOf()`，根据线程池状态和线程池worker数量，生成ctl值
private static int ctlOf(int rs, int wc) { return rs | wc; }

/*
 * Bit field accessors that don't require unpacking ctl.
 * These depend on the bit layout and on workerCount being never negative.
 */
// 8. `runStateLessThan()`，线程池状态小于xx
private static boolean runStateLessThan(int c, int s) {
    return c < s;
}
// 9. `runStateAtLeast()`，线程池状态大于等于xx
private static boolean runStateAtLeast(int c, int s) {
    return c >= s;
}
```

### 2、构造方法

```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) {
    // 基本类型参数校验
    if (corePoolSize < 0 ||
        maximumPoolSize <= 0 ||
        maximumPoolSize < corePoolSize ||
        keepAliveTime < 0)
        throw new IllegalArgumentException();
    // 空指针校验
    if (workQueue == null || threadFactory == null || handler == null)
        throw new NullPointerException();
    this.corePoolSize = corePoolSize;
    this.maximumPoolSize = maximumPoolSize;
    this.workQueue = workQueue;
    // 根据传入参数`unit`和`keepAliveTime`，将存活时间转换为纳秒存到变量`keepAliveTime `中
    this.keepAliveTime = unit.toNanos(keepAliveTime);
    this.threadFactory = threadFactory;
    this.handler = handler;
}
```

### 3、提交执行task的过程

```java
public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    /*
     * Proceed in 3 steps:
     *
     * 1. If fewer than corePoolSize threads are running, try to
     * start a new thread with the given command as its first
     * task.  The call to addWorker atomically checks runState and
     * workerCount, and so prevents false alarms that would add
     * threads when it shouldn't, by returning false.
     *
     * 2. If a task can be successfully queued, then we still need
     * to double-check whether we should have added a thread
     * (because existing ones died since last checking) or that
     * the pool shut down since entry into this method. So we
     * recheck state and if necessary roll back the enqueuing if
     * stopped, or start a new thread if there are none.
     *
     * 3. If we cannot queue task, then we try to add a new
     * thread.  If it fails, we know we are shut down or saturated
     * and so reject the task.
     */
    int c = ctl.get();
    // worker数量比核心线程数小，直接创建worker执行任务
    if (workerCountOf(c) < corePoolSize) {
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
    // worker数量超过核心线程数，任务直接进入队列
    if (isRunning(c) && workQueue.offer(command)) {
        int recheck = ctl.get();
        // 线程池状态不是RUNNING状态，说明执行过shutdown命令，需要对新加入的任务执行reject()操作。
        // 这儿为什么需要recheck，是因为任务入队列前后，线程池的状态可能会发生变化。
        if (! isRunning(recheck) && remove(command))
            reject(command);
        // 这儿为什么需要判断0值，主要是在线程池构造方法中，核心线程数允许为0
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
    // 如果线程池不是运行状态，或者任务进入队列失败，则尝试创建worker执行任务。
    // 这儿有3点需要注意：
    // 1. 线程池不是运行状态时，addWorker内部会判断线程池状态
    // 2. addWorker第2个参数表示是否创建核心线程
    // 3. addWorker返回false，则说明任务执行失败，需要执行reject操作
    else if (!addWorker(command, false))
        reject(command);
}
```

### 4、addworker源码解析

```java
private boolean addWorker(Runnable firstTask, boolean core) {
    retry:
    // 外层自旋
    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);

        // 这个条件写得比较难懂，我对其进行了调整，和下面的条件等价
        // (rs > SHUTDOWN) || 
        // (rs == SHUTDOWN && firstTask != null) || 
        // (rs == SHUTDOWN && workQueue.isEmpty())
        // 1. 线程池状态大于SHUTDOWN时，直接返回false
        // 2. 线程池状态等于SHUTDOWN，且firstTask不为null，直接返回false
        // 3. 线程池状态等于SHUTDOWN，且队列为空，直接返回false
        // Check if queue empty only if necessary.
        if (rs >= SHUTDOWN &&
            ! (rs == SHUTDOWN &&
               firstTask == null &&
               ! workQueue.isEmpty()))
            return false;

        // 内层自旋
        for (;;) {
            int wc = workerCountOf(c);
            // worker数量超过容量，直接返回false
            if (wc >= CAPACITY ||
                wc >= (core ? corePoolSize : maximumPoolSize))
                return false;
            // 使用CAS的方式增加worker数量。
            // 若增加成功，则直接跳出外层循环进入到第二部分
            if (compareAndIncrementWorkerCount(c))
                break retry;
            c = ctl.get();  // Re-read ctl
            // 线程池状态发生变化，对外层循环进行自旋
            if (runStateOf(c) != rs)
                continue retry;
            // 其他情况，直接内层循环进行自旋即可
            // else CAS failed due to workerCount change; retry inner loop
        } 
    }
    boolean workerStarted = false;
    boolean workerAdded = false;
    Worker w = null;
    try {
        w = new Worker(firstTask);
        final Thread t = w.thread;
        if (t != null) {
            final ReentrantLock mainLock = this.mainLock;
            // worker的添加必须是串行的，因此需要加锁
            mainLock.lock();
            try {
                // Recheck while holding lock.
                // Back out on ThreadFactory failure or if
                // shut down before lock acquired.
                // 这儿需要重新检查线程池状态
                int rs = runStateOf(ctl.get());

                if (rs < SHUTDOWN ||
                    (rs == SHUTDOWN && firstTask == null)) {
                    // worker已经调用过了start()方法，则不再创建worker
                    if (t.isAlive()) // precheck that t is startable
                        throw new IllegalThreadStateException();
                    // worker创建并添加到workers成功
                    workers.add(w);
                    // 更新`largestPoolSize`变量
                    int s = workers.size();
                    if (s > largestPoolSize)
                        largestPoolSize = s;
                    workerAdded = true;
                }
            } finally {
                mainLock.unlock();
            }
            // 启动worker线程
            if (workerAdded) {
                t.start();
                workerStarted = true;
            }
        }
    } finally {
        // worker线程启动失败，说明线程池状态发生了变化（关闭操作被执行），需要进行shutdown相关操作
        if (! workerStarted)
            addWorkerFailed(w);
    }
    return workerStarted;
}
```

### 5、线程池worker任务单元

```java
private final class Worker
    extends AbstractQueuedSynchronizer
    implements Runnable
{
    /**
     * This class will never be serialized, but we provide a
     * serialVersionUID to suppress a javac warning.
     */
    private static final long serialVersionUID = 6138294804551838833L;

    /** Thread this worker is running in.  Null if factory fails. */
    final Thread thread;
    /** Initial task to run.  Possibly null. */
    Runnable firstTask;
    /** Per-thread task counter */
    volatile long completedTasks;

    /**
     * Creates with given first task and thread from ThreadFactory.
     * @param firstTask the first task (null if none)
     */
    Worker(Runnable firstTask) {
        setState(-1); // inhibit interrupts until runWorker
        this.firstTask = firstTask;
        // 这儿是Worker的关键所在，使用了线程工厂创建了一个线程。传入的参数为当前worker
        this.thread = getThreadFactory().newThread(this);
    }

    /** Delegates main run loop to outer runWorker  */
    public void run() {
        runWorker(this);
    }

    // 省略代码...
}
```

### 6、核心线程执行逻辑-runworker

```java
final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    Runnable task = w.firstTask;
    w.firstTask = null;
    // 调用unlock()是为了让外部可以中断
    w.unlock(); // allow interrupts
    // 这个变量用于判断是否进入过自旋（while循环）
    boolean completedAbruptly = true;
    try {
        // 这儿是自旋
        // 1. 如果firstTask不为null，则执行firstTask；
        // 2. 如果firstTask为null，则调用getTask()从队列获取任务。
        // 3. 阻塞队列的特性就是：当队列为空时，当前线程会被阻塞等待
        while (task != null || (task = getTask()) != null) {
            // 这儿对worker进行加锁，是为了达到下面的目的
            // 1. 降低锁范围，提升性能
            // 2. 保证每个worker执行的任务是串行的
            w.lock();
            // If pool is stopping, ensure thread is interrupted;
            // if not, ensure thread is not interrupted.  This
            // requires a recheck in second case to deal with
            // shutdownNow race while clearing interrupt
            // 如果线程池正在停止，则对当前线程进行中断操作
            if ((runStateAtLeast(ctl.get(), STOP) ||
                 (Thread.interrupted() &&
                  runStateAtLeast(ctl.get(), STOP))) &&
                !wt.isInterrupted())
                wt.interrupt();
            // 执行任务，且在执行前后通过`beforeExecute()`和`afterExecute()`来扩展其功能。
            // 这两个方法在当前类里面为空实现。
            try {
                beforeExecute(wt, task);
                Throwable thrown = null;
                try {
                    task.run();
                } catch (RuntimeException x) {
                    thrown = x; throw x;
                } catch (Error x) {
                    thrown = x; throw x;
                } catch (Throwable x) {
                    thrown = x; throw new Error(x);
                } finally {
                    afterExecute(task, thrown);
                }
            } finally {
                // 帮助gc
                task = null;
                // 已完成任务数加一 
                w.completedTasks++;
                w.unlock();
            }
        }
        completedAbruptly = false;
    } finally {
        // 自旋操作被退出，说明线程池正在结束
        processWorkerExit(w, completedAbruptly);
    }
}
```

#### ThreadPoolExecutor如何做到线程复用的？

首先去执行创建这个worker时就有的任务，当执行完这个任务后，worker的生命周期并没有结束，在`while`循环中，worker会不断地调用`getTask`方法从**阻塞队列**中获取任务然后调用`task.run()`执行任务,从而达到**复用线程**的目的。只要`getTask`方法不返回`null`,此线程就不会退出。

核心线程的会一直卡在`workQueue.take`方法，被阻塞并挂起，不会占用CPU资源，直到拿到`Runnable` 然后返回（当然如果**allowCoreThreadTimeOut**设置为`true`,那么核心线程就会去调用`poll`方法，因为`poll`可能会返回`null`,所以这时候核心线程满足超时条件也会被销毁）。

非核心线程会workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) ，如果超时还没有拿到，下一次循环判断**compareAndDecrementWorkerCount**就会返回`null`,Worker对象的`run()`方法循环体的判断为`null`,任务结束，然后线程被系统回收 。



### 四种内置的拒绝策略

AbortPolicy: 默认处理方式 , 直接抛出异常RejectedExecutionException阻止系统正常运行

CallerRunsPolicy: "调用者运行"一种调节机制, 该策略既不会抛弃人物, 也不会抛出异常, 而是将某些任务回退到调用者, 从而降低新任务的流量

DiscardOldestPolicy: 抛弃队列中等待最久的任务, 然后把当前任务加入队列中尝试再次提交当前任务

DiscardPolicy: 直接丢弃任务, 不予任何处理也不抛出异常, 如果允许 任务丢失, 这是最好的一种方案



### 你是如何创建线程池数量的??

cpu密集型

 

io密集型

1. 由于io密集型任务线程并不是一直在执行任务, 则应配置尽可能多的线程, 如CPU核数*2

2. 该任务需要大量的io, 即大量的阻塞. 

    > 在单线程上运行io密集型的任务会导致浪费大量的CPU运算能力浪费在等待, 所以在io密集型任务重使用多线程可以大大的加速程序运行, 即使在单核CPU上, 这种加速主要就是利用了被浪费掉的阻塞时间
    >
    > io密集型时, 大部分线程都阻塞, 故需要多配置线程数: 
    >
    > 参考公式: CPU核数 / (1 - 阻塞系数)           阻塞系数在0.8~0.9之间
    >
    > 比如8核CPU : 8 / (1 - 0.9) = 80个线程数



### 死锁编码及定位分析

#### 是什么 





## ForkJoinPool

```java
public class T12_ForkJoinPool {
    static int[] nums = new int[1000000];
    static final int MAX_NUM = 50000;
    static Random r = new Random();
    static {
        for(int i=0; i<nums.length; i++) {
            nums[i] = r.nextInt(100);
        }
        System.out.println("---" + Arrays.stream(nums).sum()); //stream api
    }
    static class AddTask extends RecursiveAction {
        int start, end;
        AddTask(int s, int e) {
            start = s;
            end = e;
        }
        @Override
        protected void compute() {
            if(end-start <= MAX_NUM) {
                long sum = 0L;
                for(int i=start; i<end; i++) sum += nums[i];
                System.out.println("from:" + start + " to:" + end + " = " + sum);
            } else {
                int middle = start + (end-start)/2;
                AddTask subTask1 = new AddTask(start, middle);
                AddTask subTask2 = new AddTask(middle, end);
                subTask1.fork();
                subTask2.fork();
            }
        }
    }
    static class AddTaskRet extends RecursiveTask<Long> {
        private static final long serialVersionUID = 1L;
        int start, end;
        AddTaskRet(int s, int e) {
            start = s;
            end = e;
        }
        @Override
        protected Long compute() {
            if(end-start <= MAX_NUM) {
                long sum = 0L;
                for(int i=start; i<end; i++) sum += nums[i];
                return sum;
            }
            int middle = start + (end-start)/2;
            AddTaskRet subTask1 = new AddTaskRet(start, middle);
            AddTaskRet subTask2 = new AddTaskRet(middle, end);
            subTask1.fork();
            subTask2.fork();
            return subTask1.join() + subTask2.join();
        }
    }
    public static void main(String[] args) throws IOException {
        /*ForkJoinPool fjp = new ForkJoinPool();
                  AddTask task = new AddTask(0, nums.length);
                  fjp.execute(task);*/
        T12_ForkJoinPool temp = new T12_ForkJoinPool();
        ForkJoinPool fjp = new ForkJoinPool();
        AddTaskRet task = new AddTaskRet(0, nums.length);
        fjp.execute(task);
        long result = task.join();
        System.out.println(result);
        //System.in.read();
    }
}
```

## Callable接口

这是类似Runnable的类, 但是有返回值

```java
public class T03_Callable {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        Callable<String> c = new Callable() {
            @Override
            public String call() throws Exception {
            	TimeUnit.MILLISECONDS.sleep(500);
                return "Hello Callable";
            }
        };
        ExecutorService executor = Executors.newCachedThreadPool();
        Future<String> future = executor.submit(c); //异步
        System.out.println(future.get());//阻塞
        executor.shutdown();
    }
}
```

## Futrue接口

```java
public abstract interface Future<V> {
    public abstract boolean cancel(boolean paramBoolean);
    public abstract boolean isCancelled();
    public abstract boolean isDone();
    public abstract V get() throws InterruptedException, ExecutionException;
    public abstract V get(long paramLong, TimeUnit paramTimeUnit)
            throws InterruptedException, ExecutionException, TimeoutException;
}
```



## FutureTask(Futrue接口实现类)

```java
public class T06_00_Future {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        FutureTask<Integer> task = new FutureTask<>(()->{
            TimeUnit.MILLISECONDS.sleep(500);
            return 1000;
        });
        ExecutorService executor = Executors.newCachedThreadPool();
        executor.submit(task); //异步
        System.out.println(task.get()); //阻塞
    }
}
```

## CompletableFuture

使用`Future`获得异步执行结果时，要么调用阻塞方法`get()`，要么轮询看`isDone()`是否为`true`，这两种方法都不是很好，因为主线程也会被迫等待。

从Java 8开始引入了`CompletableFuture`，它针对`Future`做了改进，可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法。

```java
public class Main {
    public static void main(String[] args) throws Exception {
        // 创建异步执行任务:
        CompletableFuture<Double> cf = CompletableFuture.supplyAsync(Main::fetchPrice);
        // 如果执行成功:
        cf.thenAccept((result) -> {
            System.out.println("price: " + result);
        });
        // 如果执行异常:
        cf.exceptionally((e) -> {
            e.printStackTrace();
            return null;
        });
        // 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:
        Thread.sleep(200);
    }

    static Double fetchPrice() {
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
        }
        if (Math.random() < 0.3) {
            throw new RuntimeException("fetch price failed!");
        }
        return 5 + Math.random() * 20;
    }
}
```



# 高频面试加分项

# Disruptor





# ------------------------------

# 生产者和消费者问题

```java
package Thread;


public class ProducerConsumer {
    public static void main(String[] args) {
        SyncStack ss = new SyncStack();
        Producer p = new Producer(ss);
        Consumer s = new Consumer(ss);

        new Thread(p).start();
        new Thread(s).start();
    }
}
class WoTou {
    int id;
    WoTou(int id){
        this.id = id;
    }
    public String toString(){
        return "WoTou : " + id;
    }
}
class SyncStack{
    int index = 0;
    WoTou[] arrWT = new WoTou[6];
    public synchronized void push(WoTou wt){
        while(index == arrWT.length){
            try {
                this.wait();//当前执行的线程wait(), 且必须synchronized
            }catch (InterruptedException e){
                e.printStackTrace();
            }
        }
        this.notify();//叫醒另一个线程,. 好像放在synchronized里面任意一行都行...不知道
        arrWT[index] = wt;
        index++;
    }
    public synchronized WoTou pop(){
        while(index == 0){
            try {
                this.wait();//当前执行的线程wait(), 且必须synchronized
            }catch (InterruptedException e){
                e.printStackTrace();
            }
        }
        this.notify();//叫醒一个
        index--;
        return arrWT[index];
    }
}
class Producer implements Runnable {
    SyncStack ss = null;
    Producer (SyncStack ss){
        this.ss = ss;
    }
    public void run (){
        for(int i = 0; i < 20; i++){
            WoTou wt = new WoTou(i);
            ss.push(wt);
            System.out.println("生产了" + wt);
//            try {
//                Thread.sleep(1000);
//            }catch (InterruptedException e){
//                e.printStackTrace();
//            }
        }
    }
}
class Consumer implements Runnable {
    SyncStack ss = null;
    Consumer (SyncStack ss){
        this.ss = ss;
    }
    public void run (){
        for(int i = 0; i < 20; i++){
            WoTou wt = new WoTou(i);
            ss.pop();
            System.out.println("消费了" + wt);
//            try {
//                Thread.sleep(1000);
//            }catch (InterruptedException e){
//                e.printStackTrace();
//            }
        }
    }
}
```

# ﻿思考题

1：A线程正在执行一个对象中的同步方法，B线程是否可以同时执行同一个对象中的非同步方法？
2：同上，B线程是否可以同时执行同一个对象中的另一个同步方法？
3：线程抛出异常会释放锁吗？
4：volatile和synchronized区别？
5：写一个程序，证明AtomXXX类比synchronized更高效
6：AtomXXX类可以保证可见性吗？请写一个程序来证明
7：写一个程序证明AtomXXX类的多个方法并不构成原子性
8：写一个程序模拟死锁
9：写一个程序，在main线程中启动100个线程，100个线程完成后，主线程打印“完成”，使用join()和countdownlatch都可以完成，请比较异同。
10：一个高效的游戏服务器应该如何设计架构？

# 源码阅读指南

阅读源码前:

1. 要有数据结构基础
2. 要有设计模式基础
3. 不要吹毛求疵, 懂别人的思路即可, 不要扣细节, 没必要边边角角都去看, 

阅读源码原则:

1. 跑步起来不读
2. 解决问题就好
3. 一条线索走到底
4. 无关细节略过

阅读的时候最好画图理解